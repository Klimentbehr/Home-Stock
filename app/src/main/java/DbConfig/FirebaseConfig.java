package DbConfig;

import android.util.Log;

import androidx.annotation.NonNull;

// imports for the Get method
import com.google.android.gms.tasks.Task;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;

// map and hash for testing
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

// calendar
import java.util.Calendar;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.Locale;

// firebase queries
import com.google.firebase.firestore.DocumentReference;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnCompleteListener;
import com.google.firebase.firestore.QueryDocumentSnapshot;
import com.google.firebase.firestore.QuerySnapshot;


// TODO: CREATE CLASS THAT HAS ALL VARIABLES WE NEED INSIDE AN ITEM. ONE FOR EACH THING!

public class FirebaseConfig {

    private FirebaseFirestore db;
    private Map<String, Object> item;
    private static final String TAG = "DbConnection";

    public void ConnectDatabase(){
        db = FirebaseFirestore.getInstance();
        item = new HashMap<>();
    }

    // creates the item data structure to push into the Db.
    // some problems: what does an item need?
    // TODO: figure out what we need inside the Document in the Db
    // example: expirationDate, name, insertDate, lastUpdated, quantity
    // suggestion: since we are saving the variable globally in this class, don't

    // think we need to return anything. it can be void, will think about the
    // implications later!
    public Map<String, Object> CreateItem(String _key, String _value){
        item.put(_key, _value);

        return item;
    }

    // helper method to grab date!
    public String GetDate(){
        // Get the current date and time
        Calendar calendar = Calendar.getInstance();

        // Format the timestamp as a string
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());

        String formattedTimestamp = dateFormat.format(calendar.getTime());

        return formattedTimestamp;
    }

    // pushes into the db
    // uses the instance we first initialized in the ConnectDatabase, and connects to the specific
    // collection of InventoryItems. The document will be auto-generated by the FirebaseConsole
    // example on how it looks in the Db: https://imgur.com/a/7xbV4NJ
    // in this case, we pushed the _item which had only one field&value.

    // TODO: Figure out how we wanna divide collections
    // problem:
    // 1. we need to save users, items, and what more?
    // 2. should we divide food and other items into different collections?
    // 3. cases for duplicated items; should we use auto-id? to identify them into the Db?
    // 4. checks for bad data before pushing
    // 5. handlers for different collections? we can make switch cases inside this method
    public void InsertDb(Map<String, Object> _item){


        // Add the current date and time to the item map
        _item.put("insertDate", GetDate());

        db.collection("InventoryItems")
                .add(_item)
                .addOnSuccessListener(new OnSuccessListener<DocumentReference>() {
                    @Override
                    public void onSuccess(DocumentReference documentReference) {
                        Log.d(TAG, "DocumentSnapshot added with ID: " + documentReference.getId());
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        Log.w(TAG, "Error adding document", e);
                    }
                });
    }

    // Deletes from the Db based on the documentId.
    // Still figuring out if that is sufficient.
    // TODO: only deletes from InventoryItems collection, maybe add another parameter for the collection
    public void DeleteFromId(String _documentId){

        db.collection("InventoryItems").document(_documentId)
                .delete()
                .addOnSuccessListener(new OnSuccessListener<Void>() {
                    @Override
                    public void onSuccess(Void aVoid) {
                        Log.d(TAG, "DocumentSnapshot successfully deleted! ID: " + _documentId);
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        Log.w(TAG, "Error deleting document, ID: " + _documentId, e);
                    }
                });
    }

    // Gets everything inside the collection
    // PROBLEM: it will be necessary some kind of pagination maybe depending on the amount of items in the collection
    // TODO: implement error handling
    public List<Map<String, Object>> GetAll(){

        // for testing currently
        List<Map<String, Object>> resultList = new ArrayList<>();

        db.collection("InventoryItems")
                .get()
                .addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                    @Override
                    public void onComplete(@NonNull Task<QuerySnapshot> task) {
                        if (task.isSuccessful()) {
                            for (QueryDocumentSnapshot document : task.getResult()) {
                                    Map<String, Object> data = document.getData();
                                    resultList.add(data);
                            }
                        } else {
                            Log.w(TAG, "Error getting documents.", task.getException());
                        }
                    }
                });

        return resultList;
    }

    // Not sure how much this will be used.
    // If you want to find something in the Db with an specific value, let's say
    // parameter = "name" and value = "Whole Milk", you can find all the data in the Db that has
    // these two on it.
    // PROBLEM: if there are duplicates of the same item in the Db, it will return all of them. Seems like
    // just the parameter name and its value.
    // POSSIBLE SOLUTION: add the documentId parameter inside the object.
    // TODO: in the future, figure out if there will need to be changes here, possibly when we are going to display
    // everything to the user.
    public List<Map<String, Object>> GetByParameterValue(String _parameter, String _value){

        // for testing currently
        List<Map<String, Object>> resultList = new ArrayList<>();

        // gets all the data that has the same parameter inside, with the same value.
        db.collection("InventoryItems").whereEqualTo(_parameter, _value)
                .get()
                .addOnSuccessListener(new OnSuccessListener<QuerySnapshot>() {
                    @Override
                    public void onSuccess(QuerySnapshot queryDocumentSnapshots) {
                        List<DocumentSnapshot> documents = queryDocumentSnapshots.getDocuments();

                        // for each document inside the collection that matches the filter,
                        // adds to the resultList
                        for (DocumentSnapshot document : documents) {
                            Map<String, Object> data = document.getData();
                            resultList.add(data);

                            Log.d(TAG, "DOCUMENTID FROM GETBYPARAMETER:" + document.getId());
                        }
                    }
                })
                .addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {
                        // error retrieving documents
                    }
                });

        return resultList;
    }

    // I think we need the id always.
    // Updates whatever you want from the Db based on the documentId
    public void UpdateFromId(String _documentId){

    }
}

